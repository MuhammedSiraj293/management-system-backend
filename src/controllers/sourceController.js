import Source from '../models/Source.js';
import { HTTP_STATUS, LEAD_SOURCES } from '../utils/constants.js';
import logger from '../config/logger.js';

/**
 * Fetches all lead sources.
 * Used by the 'Sources' page in the frontend.
 */
export const getAllSources = async (req, res) => {
  try {
    const sources = await Source.find().sort({ createdAt: -1 }).lean();
    res.status(HTTP_STATUS.OK).json({ success: true, data: sources });
  } catch (error) {
    logger.error('Error fetching sources:', error.message);
    res
      .status(HTTP_STATUS.INTERNAL_SERVER_ERROR)
      .json({ success: false, message: 'Error fetching sources' });
  }
};

/**
 * Creates a new lead source.
 * Used by the 'Add New Source' form in the frontend.
 */
export const createSource = async (req, res) => {
  try {
    const { name, platform, config } = req.body;

    // 1. Validate input
    if (!name || !platform) {
      return res.status(HTTP_STATUS.BAD_REQUEST).json({
        success: false,
        message: 'Name and platform are required.',
      });
    }

    // 2. Check if platform is valid
    if (!Object.values(LEAD_SOURCES).includes(platform)) {
      return res
        .status(HTTP_STATUS.BAD_REQUEST)
        .json({ success: false, message: 'Invalid platform type.' });
    }

    // 3. Check for duplicate name
    const existingSource = await Source.findOne({ name });
    if (existingSource) {
      return res.status(HTTP_STATUS.BAD_REQUEST).json({
        success: false,
        message: 'A source with this name already exists.',
      });
    }

    // 4. Create new source
    // The 'identifierToken' is auto-generated by the model (uuidv4)
    const newSource = new Source({
      name,
      platform,
      config: {
        sheetId: config?.sheetId || null,
        sheetName: config?.sheetName || 'Leads',
        bitrixPipelineId: config?.bitrixPipelineId || null,
      },
      isActive: true,
    });

    await newSource.save();

    logger.info(`New source created: ${newSource.name} (ID: ${newSource._id})`);
    res.status(HTTP_STATUS.CREATED).json({ success: true, data: newSource });
  } catch (error) {
    logger.error('Error creating source:', error.message);
    res
      .status(HTTP_STATUS.INTERNAL_SERVER_ERROR)
      .json({ success: false, message: 'Error creating source' });
  }
};

/**
 * Updates an existing lead source.
 * Used to edit Sheet IDs, Bitrix IDs, or activate/deactivate.
 */
export const updateSource = async (req, res) => {
  try {
    const { sourceId } = req.params;
    const { name, isActive, config } = req.body;

    const source = await Source.findById(sourceId);
    if (!source) {
      return res
        .status(HTTP_STATUS.NOT_FOUND)
        .json({ success: false, message: 'Source not found.' });
    }

    // Update fields if they were provided
    if (name) source.name = name;
    if (typeof isActive === 'boolean') source.isActive = isActive;
    if (config) {
      source.config.sheetId = config.sheetId || source.config.sheetId;
      source.config.sheetName = config.sheetName || source.config.sheetName;
      source.config.bitrixPipelineId =
        config.bitrixPipelineId || source.config.bitrixPipelineId;
    }

    await source.save();

    logger.info(`Source updated: ${source.name} (ID: ${source._id})`);
    res.status(HTTP_STATUS.OK).json({ success: true, data: source });
  } catch (error) {
    logger.error('Error updating source:', error.message);
    res
      .status(HTTP_STATUS.INTERNAL_SERVER_ERROR)
      .json({ success: false, message: 'Error updating source' });
  }
};

/**
 * Deletes a lead source.
 * (Note: We might want to just "deactivate" instead of delete)
 */
export const deleteSource = async (req, res) => {
  try {
    const { sourceId } = req.params;

    const source = await Source.findById(sourceId);
    if (!source) {
      return res
        .status(HTTP_STATUS.NOT_FOUND)
        .json({ success: false, message: 'Source not found.' });
    }

    // TODO: Add logic here. We probably should not delete a source
    // that has leads associated with it.
    // For now, we'll just deactivate it.
    source.isActive = false;
    await source.save();

    // Or, to permanently delete:
    // await Source.findByIdAndDelete(sourceId);

    logger.info(`Source deactivated: ${source.name} (ID: ${source._id})`);
    res.status(HTTP_STATUS.OK).json({
      success: true,
      message: 'Source deactivated successfully.',
    });
  } catch (error) {
    logger.error('Error deleting source:', error.message);
    res
      .status(HTTP_STATUS.INTERNAL_SERVER_ERROR)
      .json({ success: false, message: 'Error deleting source' });
  }
};